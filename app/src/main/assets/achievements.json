// app/src/main/java/com/liveongames/liveon/ui/LiveonGameScreen.kt
package com.liveongames.liveon.ui

import android.content.Context
import android.util.Log
import androidx.compose.foundation.*
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.hilt.navigation.compose.hiltViewModel
import com.liveongames.liveon.R
import com.liveongames.liveon.ui.components.LiveonLogo
import com.liveongames.liveon.viewmodel.GameViewModel
import com.liveongames.domain.model.GameEvent
import org.json.JSONObject
import kotlin.random.Random

@Composable
fun LiveonGameScreen(viewModel: GameViewModel = hiltViewModel()) {
val context = LocalContext.current
val uiState by viewModel.uiState.collectAsState()
var isLifeManagementExpanded by remember { mutableStateOf(false) }
var isLifebookExpanded by remember { mutableStateOf(false) }

// Persistent storage for Lifebook entries - using strings for saveable compatibility
var lifeHistoryEntries by rememberSaveable {
mutableStateOf(listOf<String>())
}

// Scroll state for Lifebook
val lifebookScrollState = rememberScrollState()

// Load random events from JSON assets
val randomEvents = remember(context) {
loadRandomEventsFromAssets(context)
}

// Generate random life events when aging up (1-3 random count each time)
var lastAge by remember { mutableStateOf<Int?>(null) }
LaunchedEffect(uiState.playerStats?.age) {
val currentAge = uiState.playerStats?.age ?: 0
if (lastAge != null && currentAge > lastAge!!) {
// Generate random number of events (1-3) each time
val eventCount = Random.nextInt(1, 4) // 1, 2, or 3 events
val newEntries = generateRandomLifeEvents(randomEvents, currentAge, eventCount)
.map { event -> "Age $currentAge: $event" }
.filter { entry -> !lifeHistoryEntries.contains(entry) }

if (newEntries.isNotEmpty()) {
lifeHistoryEntries = (lifeHistoryEntries + newEntries).distinct()
}
}
lastAge = currentAge
}

Box(
modifier = Modifier
.fillMaxSize()
.background(MaterialTheme.colorScheme.background)
) {
Column(
modifier = Modifier
.fillMaxSize()
.padding(16.dp),
horizontalAlignment = Alignment.CenterHorizontally
) {
// Logo Header
LiveonLogo(
modifier = Modifier
.padding(bottom = 16.dp)
.fillMaxWidth()
)

// Main content in a scrollable column
Column(
modifier = Modifier
.fillMaxWidth()
.weight(1f)
.verticalScroll(rememberScrollState()),
horizontalAlignment = Alignment.CenterHorizontally
) {
// Lifebook Section (Persistent Event Log) - Expandable
Card(
modifier = Modifier
.fillMaxWidth()
.height(if (isLifebookExpanded) 350.dp else 200.dp),
elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
shape = androidx.compose.foundation.shape.RoundedCornerShape(12.dp)
) {
Column(
modifier = Modifier
.fillMaxSize()
.padding(16.dp)
) {
// Header with expand/collapse button
Row(
modifier = Modifier
.fillMaxWidth()
.clickable {
isLifebookExpanded = !isLifebookExpanded
},
verticalAlignment = Alignment.CenterVertically
) {
Icon(
painter = painterResource(id = R.drawable.ic_yearbook),
contentDescription = null,
modifier = Modifier.size(24.dp),
tint = MaterialTheme.colorScheme.primary
)
Spacer(modifier = Modifier.width(8.dp))
Text(
text = "Lifebook (${lifeHistoryEntries.size} entries)",
style = MaterialTheme.typography.titleLarge,
color = MaterialTheme.colorScheme.primary,
fontWeight = FontWeight.Bold
)
Spacer(modifier = Modifier.weight(1f))
Icon(
painter = painterResource(id = if (isLifebookExpanded) R.drawable.ic_collapse else R.drawable.ic_expand),
contentDescription = if (isLifebookExpanded) "Collapse" else "Expand",
modifier = Modifier.size(20.dp),
tint = MaterialTheme.colorScheme.onSurfaceVariant
)
}
Spacer(modifier = Modifier.height(12.dp))

// Event log content with expandable scrolling and auto-scroll to new entries
Box(
modifier = Modifier
.fillMaxWidth()
.weight(1f)
) {
Column(
modifier = Modifier
.fillMaxSize()
.verticalScroll(lifebookScrollState)
) {
if (lifeHistoryEntries.isEmpty()) {
Text(
text = "Your life story will appear here...",
style = MaterialTheme.typography.bodyMedium,
color = MaterialTheme.colorScheme.onSurfaceVariant,
modifier = Modifier.align(Alignment.CenterHorizontally)
)
} else {
lifeHistoryEntries.forEachIndexed { index, entry ->
LifebookEntryItem(
entry = entry,
onEntryClick = {
// TODO: Show detailed event view
}
)
// Add spacing between entries
if (index < lifeHistoryEntries.size - 1) {
Spacer(modifier = Modifier.height(6.dp))
}
}
}
}
}

// Auto-scroll to bottom when new entries are added
LaunchedEffect(lifeHistoryEntries.size) {
// Small delay to ensure layout is complete
kotlinx.coroutines.delay(100)
lifebookScrollState.animateScrollTo(lifebookScrollState.maxValue)
}
}
}

Spacer(modifier = Modifier.height(24.dp))

// Main Action Buttons with circular age up button
Column(
modifier = Modifier.fillMaxWidth(),
horizontalAlignment = Alignment.CenterHorizontally,
verticalArrangement = Arrangement.spacedBy(16.dp)
) {
IconButton(
onClick = {
viewModel.ageUp()
},
modifier = Modifier
.size(80.dp)
.clip(CircleShape),
enabled = !uiState.isLoading,
colors = IconButtonDefaults.iconButtonColors(
containerColor = MaterialTheme.colorScheme.primary,
contentColor = MaterialTheme.colorScheme.onPrimary
)
) {
if (uiState.isLoading) {
CircularProgressIndicator(
modifier = Modifier.size(32.dp),
color = MaterialTheme.colorScheme.onPrimary,
strokeWidth = 3.dp
)
} else {
Icon(
painter = painterResource(id = R.drawable.ic_hourglass),
contentDescription = "Advance Time",
modifier = Modifier.size(32.dp),
tint = Color.Unspecified
)
}
}

Text(
text = "Advance Time",
style = MaterialTheme.typography.bodyMedium,
color = MaterialTheme.colorScheme.onSurfaceVariant
)

// Combined Career & Social Buttons
Row(
modifier = Modifier.fillMaxWidth(),
horizontalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterHorizontally)
) {
OutlinedButton(
onClick = { /* TODO: Navigate to Career */ },
modifier = Modifier
.width(140.dp)
.height(50.dp)
) {
Icon(
painter = painterResource(id = R.drawable.ic_business),
contentDescription = null,
modifier = Modifier.size(18.dp),
tint = MaterialTheme.colorScheme.primary
)
Spacer(modifier = Modifier.width(8.dp))
Text("Career")
}

OutlinedButton(
onClick = { /* TODO: Navigate to Social */ },
modifier = Modifier
.width(140.dp)
.height(50.dp)
) {
Icon(
painter = painterResource(id = R.drawable.ic_people),
contentDescription = null,
modifier = Modifier.size(18.dp),
tint = MaterialTheme.colorScheme.primary
)
Spacer(modifier = Modifier.width(8.dp))
Text("Social")
}
}
}

Spacer(modifier = Modifier.height(24.dp))

// Life Management Menu (Expandable)
Card(
modifier = Modifier
.fillMaxWidth()
.height(if (isLifeManagementExpanded) 350.dp else 80.dp),
elevation = CardDefaults.cardElevation(defaultElevation = 4.dp),
shape = androidx.compose.foundation.shape.RoundedCornerShape(12.dp)
) {
Column(
modifier = Modifier
.fillMaxSize()
.padding(16.dp)
) {
// Header - Always visible
Row(
modifier = Modifier
.fillMaxWidth()
.clickable { isLifeManagementExpanded = !isLifeManagementExpanded }
.padding(vertical = 8.dp),
verticalAlignment = Alignment.CenterVertically
) {
Icon(
painter = painterResource(id = R.drawable.ic_settings),
contentDescription = null,
modifier = Modifier.size(24.dp),
tint = MaterialTheme.colorScheme.primary
)
Spacer(modifier = Modifier.width(8.dp))
Text(
text = "Life Management",
style = MaterialTheme.typography.titleLarge,
color = MaterialTheme.colorScheme.primary,
fontWeight = FontWeight.Bold
)
Spacer(modifier = Modifier.weight(1f))
Icon(
painter = painterResource(id = if (isLifeManagementExpanded) R.drawable.ic_collapse else R.drawable.ic_expand),
contentDescription = if (isLifeManagementExpanded) "Collapse" else "Expand",
modifier = Modifier.size(20.dp),
tint = MaterialTheme.colorScheme.onSurfaceVariant
)
}

// Content - Only shown when expanded
if (isLifeManagementExpanded) {
Spacer(modifier = Modifier.height(12.dp))

// Menu items with scrolling
Column(
modifier = Modifier
.fillMaxWidth()
.height(220.dp)
.verticalScroll(rememberScrollState())
) {
val menuItems = listOf(
MenuItemData(R.drawable.ic_law, "Crime Records", "View criminal history") { },
MenuItemData(R.drawable.ic_band, "Pet Management", "Adopt companions") { },
MenuItemData(R.drawable.ic_education, "Education", "Manage schooling") { },
MenuItemData(R.drawable.ic_relationship, "Relationships", "View connections") { },
MenuItemData(R.drawable.ic_health, "Health Records", "View medical history") { },
MenuItemData(R.drawable.ic_travel, "Travel Log", "View places visited") { },
MenuItemData(R.drawable.ic_save, "Save Game", "Manage saves") { },
MenuItemData(R.drawable.ic_settings, "Settings", "Game preferences") { }
)

menuItems.forEachIndexed { index, item ->
MenuItemRow(item = item)
if (index < menuItems.size - 1) {
Divider(modifier = Modifier.padding(vertical = 8.dp))
}
}
}
}
}
}

Spacer(modifier = Modifier.height(100.dp)) // Space for bottom stats
}
}

// Character Stats at Bottom
Card(
modifier = Modifier
.align(Alignment.BottomCenter)
.fillMaxWidth()
.height(160.dp),
elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),
shape = androidx.compose.foundation.shape.RoundedCornerShape(
topStart = 20.dp,
topEnd = 20.dp
)
) {
Column(
modifier = Modifier
.fillMaxSize()
.padding(12.dp)
) {
Row(
modifier = Modifier.fillMaxWidth(),
verticalAlignment = Alignment.CenterVertically
) {
Icon(
painter = painterResource(id = R.drawable.ic_person),
contentDescription = null,
modifier = Modifier.size(20.dp),
tint = MaterialTheme.colorScheme.primary
)
Spacer(modifier = Modifier.width(6.dp))
Text(
text = "Stats",
style = MaterialTheme.typography.titleMedium,
color = MaterialTheme.colorScheme.primary,
fontWeight = FontWeight.Bold
)
}

Spacer(modifier = Modifier.height(8.dp))

// Show ALL 6 stats properly arranged
Column(modifier = Modifier.fillMaxWidth()) {
// Row 1: Age, Health, Happiness
Row(
modifier = Modifier.fillMaxWidth(),
horizontalArrangement = Arrangement.SpaceBetween
) {
CompactStatItem("Age", uiState.playerStats?.age?.toString() ?: "0", R.drawable.ic_yearbook, Color(0xFF9C27B0))
CompactStatItem("Health", uiState.playerStats?.health?.toString() ?: "0", R.drawable.ic_health, Color(0xFF4CAF50))
CompactStatItem("Happiness", uiState.playerStats?.happiness?.toString() ?: "0", R.drawable.ic_happiness_new, Color(0xFFFF9800))
}
Spacer(modifier = Modifier.height(8.dp))
// Row 2: Intelligence, Money, Social
Row(
modifier = Modifier.fillMaxWidth(),
horizontalArrangement = Arrangement.SpaceBetween
) {
CompactStatItem("Intelligence", uiState.playerStats?.intelligence?.toString() ?: "0", R.drawable.ic_brain, Color(0xFF2196F3))
CompactStatItem("Money", "$${uiState.playerStats?.money?.toString() ?: "0"}", R.drawable.ic_money, Color(0xFF9E9E9E))
CompactStatItem("Social", uiState.playerStats?.social?.toString() ?: "0", R.drawable.ic_people, Color(0xFFF44336))
}
}
}
}

// Event dialog - Only show meaningful events (not age progression)
uiState.activeEvents
.filter { event ->
!event.title.contains("Age", ignoreCase = true) &&
!event.title.contains("Year", ignoreCase = true) &&
!event.title.contains("Birthday", ignoreCase = true)
}
.firstOrNull()
?.let { firstEvent ->
EventDialogComposable(
event = firstEvent,
onChoiceSelected = { choiceId ->
viewModel.makeChoice(firstEvent.id, choiceId)
},
onDismiss = {
viewModel.dismissEvent(firstEvent.id)
}
)
}
}
}

// Load random events from JSON assets
fun loadRandomEventsFromAssets(context: Context): Map<String, List<String>> {
return try {
val jsonString = context.assets.open("random_events.json").bufferedReader().use { it.readText() }
val jsonObject = JSONObject(jsonString)

val categories = listOf(
"world_events", "local_events", "social_events",
"personal_events", "travel_events", "pop_culture_events",
"career_events", "random_events"
)

categories.associateWith { category ->
val jsonArray = jsonObject.getJSONArray(category)
val events = mutableListOf<String>()
for (i in 0 until jsonArray.length()) {
events.add(jsonArray.getString(i))
}
events
}
} catch (e: Exception) {
Log.e("Lifebook", "Error loading random events: ${e.message}")
// Fallback to some sample events if loading fails
mapOf(
"world_events" to listOf("A major breakthrough in renewable energy was announced globally."),
"local_events" to listOf("The local community center held its annual summer fair."),
"social_events" to listOf("Your childhood friend sent you a thoughtful message."),
"personal_events" to listOf("You felt a new sense of clarity about your future."),
"travel_events" to listOf("You discovered an interesting travel documentary."),
"pop_culture_events" to listOf("A new indie band released a catchy single."),
"career_events" to listOf("You learned a new skill that could help your career."),
"random_events" to listOf("You found a lucky coin on the sidewalk.")
)
}
}

// Generate random life events when aging up - with controlled count
fun generateRandomLifeEvents(eventsMap: Map<String, List<String>>, age: Int, eventCount: Int): List<String> {
val events = mutableListOf<String>()
val random = Random(System.currentTimeMillis())

// Generate controlled number of events
repeat(eventCount) {
// Randomly select a category
val categories = eventsMap.keys.toList()
val category = categories.random()

// Get events from that category
val categoryEvents = eventsMap[category] ?: emptyList()
if (categoryEvents.isNotEmpty()) {
events.add(categoryEvents.random())
}
}

return events.distinct() // Remove duplicates
}

// Lifebook Entry Item Composable - with smaller text
@Composable
fun LifebookEntryItem(
entry: String,
onEntryClick: () -> Unit
) {
Surface(
modifier = Modifier
.fillMaxWidth()
.clickable { onEntryClick() }
.padding(vertical = 3.dp),
color = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.3f),
shape = androidx.compose.foundation.shape.RoundedCornerShape(6.dp)
) {
Column(
modifier = Modifier
.fillMaxWidth()
.padding(horizontal = 10.dp, vertical = 8.dp)
) {
Text(
text = entry,
style = MaterialTheme.typography.bodySmall, // Smaller text
color = MaterialTheme.colorScheme.onSurface,
fontWeight = FontWeight.Normal,
lineHeight = 16.sp // Better line spacing for readability
)
}
}
}

@Composable
fun CompactStatItem(
label: String,
value: String,
iconId: Int,
color: Color
) {
Row(
modifier = Modifier
.width(100.dp)
.padding(horizontal = 2.dp),
verticalAlignment = Alignment.CenterVertically
) {
Icon(
painter = painterResource(id = iconId),
contentDescription = null,
modifier = Modifier.size(14.dp),
tint = color
)
Spacer(modifier = Modifier.width(4.dp))
Column {
Text(
text = label,
style = MaterialTheme.typography.bodySmall,
color = MaterialTheme.colorScheme.onSurface,
fontSize = 10.sp
)
Text(
text = value,
style = MaterialTheme.typography.bodySmall,
color = MaterialTheme.colorScheme.onSurfaceVariant,
fontSize = 10.sp,
fontWeight = FontWeight.Medium
)
}
}
}

data class MenuItemData(
val iconResId: Int,
val title: String,
val description: String,
val onClick: () -> Unit
)

@Composable
fun MenuItemRow(item: MenuItemData) {
Surface(
modifier = Modifier
.fillMaxWidth()
.clickable { item.onClick() }
.padding(vertical = 8.dp),
color = Color.Transparent
) {
Row(
modifier = Modifier.fillMaxWidth(),
verticalAlignment = Alignment.CenterVertically
) {
Box(
modifier = Modifier
.size(40.dp)
.background(
color = MaterialTheme.colorScheme.primary.copy(alpha = 0.1f),
shape = androidx.compose.foundation.shape.CircleShape
),
contentAlignment = Alignment.Center
) {
Icon(
painter = painterResource(id = item.iconResId),
contentDescription = null,
modifier = Modifier.size(20.dp),
tint = MaterialTheme.colorScheme.primary
)
}

Spacer(modifier = Modifier.width(16.dp))

Column(modifier = Modifier.weight(1f)) {
Text(
text = item.title,
style = MaterialTheme.typography.titleMedium,
color = MaterialTheme.colorScheme.onSurface,
fontWeight = FontWeight.Medium
)
Text(
text = item.description,
style = MaterialTheme.typography.bodySmall,
color = MaterialTheme.colorScheme.onSurfaceVariant,
fontSize = 12.sp
)
}

Icon(
painter = painterResource(id = R.drawable.ic_continue),
contentDescription = null,
modifier = Modifier.size(18.dp),
tint = MaterialTheme.colorScheme.onSurfaceVariant
)
}
}
}

@Composable
fun EventDialogComposable(
event: GameEvent,
onChoiceSelected: (String) -> Unit,
onDismiss: () -> Unit
) {
AlertDialog(
onDismissRequest = onDismiss,
title = {
Text(
text = event.title,
style = MaterialTheme.typography.headlineSmall,
fontWeight = FontWeight.Bold
)
},
text = {
Column(
verticalArrangement = Arrangement.spacedBy(16.dp)
) {
Text(
text = event.description,
style = MaterialTheme.typography.bodyMedium
)

if (event.choices.isNotEmpty()) {
Text(
text = "What do you choose?",
style = MaterialTheme.typography.titleMedium,
fontWeight = FontWeight.Medium
)

event.choices.forEach { choice ->
Button(
onClick = { onChoiceSelected(choice.id) },
modifier = Modifier.fillMaxWidth(),
colors = ButtonDefaults.buttonColors(
containerColor = MaterialTheme.colorScheme.secondaryContainer,
contentColor = MaterialTheme.colorScheme.onSecondaryContainer
)
) {
Text(
text = choice.text,
fontWeight = FontWeight.Medium
)
}
Spacer(modifier = Modifier.height(8.dp))
}
}
}
},
confirmButton = {
if (event.choices.isEmpty()) {
TextButton(onClick = onDismiss) {
Text("Continue")
}
}
}
)
}